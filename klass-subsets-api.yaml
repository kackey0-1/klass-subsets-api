---
apiVersion: flux.weave.works/v1beta1
kind: HelmRelease
metadata:
  # This is the name of the 'HelmRelease' object. It is a good practice that
  # this matches the name of the Helm release itself (i.e. 'spec.releaseName')
  name: "klass-subsets-api"
  # It is important that this matches the namespace of your team
  namespace: "klass"
  annotations:
    # This tells Flux to ignore changes to the application (or underlying chart)
    flux.weave.works/ignore: "false"
    # This tells Flux to automatically deploy new versions of the app, and
    # commit changes back (i.e. updating 'spec.values.image.tag')
    flux.weave.works/automated: "true"
    # This tells Flux what pattern to use for automating deployment of
    # applications. In this case Flux will deploy any new '3.1.X' image, but not
    # '3.2' or '4' images
    flux.weave.works/tag.chart-image: glob:development-*
    # This tells Flux to temporarily lock an application (e.g. when there's a
    # bug in the latest release and you want to roll back and lock it to a
    # previous version)
    flux.weave.works/locked: "false"
spec:
  chart:
    # This is where Flux will look for resources. This should never be changed
    git: "ssh://git@github.com/statisticsnorway/platform-dev"
    # This is the Git branch where Flux should look for resources. This should
    # only be changed when testing
    ref: "master"
    # This is the path of the generic Helm chart to use for SSB applications.
    # This should never be changed
    path: "helm/charts/ssb-chart"
  # This is the name to use for the application. It is a good practice that
  # this matches the name of the 'HelmRelease' resource (i.e. 'metadata.name')
  releaseName: "klass-subsets-api"
  values:
    # This is an example documenting most overrides possible to do in a
    # `HelmRelease` resource. Some are mandatory, and some are optional. If you
    # decide to copy from this file, you do not need to copy all the comments,
    # as this is meant to be verbose as documentation.

    # Optional
    # If appType is set to "frontend" then OAuth2 Proxy sidecar will be added as a
    # sidecar and the "targetPort" will be set to "oauth2Proxy.port". The OAuth2
    # proxy dependens on a Kubernetes secret containing the configuration and client
    # credentials. For now this has to be added by the platform team from the
    # "platform" repository.
    oauth2Proxy:
      enabled: false

    # Mandatory
    # The name used for resources within the Helm chart. It usually make sense
    # to use the same name as 'releaseName'
    name: "klass-subsets-api"

    # Mandatory
    # The type of application to set up. We currently support 'frontend' and
    # 'backend'. We set up things automatically based on what you choose here,
    # so remember to use the correct type. A 'backend' application will
    # automatically be protected by Istio End User Authentication for validating
    # JWT tokens against a running Keycloak server, and 'frontend' applications
    # will get an OAuth2 Proxy for initiating a login flow, giving you the
    # opportunity to proxy the JWT token to backends if necessary (see
    # 'backends' override). Remember that a frontend application with
    # authentication needs a Keycloak client set up by the platform team
    appType: "backend"

    # Only require autentication on exact "/auth" path and paths
    # starting with "/auth/"
    istioEndUserAuth:
      enabled: true
      excludePaths:
        - name: "/"
          type: "prefix"
      includePaths:
        - name: "/auth"
          type: "exact"
        - name: "/auth/"
          type: "prefix"

    # Mandatory
    # The Kubernetes cluster name (which is also used in DNS when exposing app)
    cluster: "staging-bip-app"

    # Optional
    # This will expose the application as '<name>.<cluster>.<domain>'. In this
    # case, the app will be exposed as 'podinfo.staging-bip-app.ssb.no'. To be
    # able to expose an app, the cluster needs to run Istio (which is normally
    # the default). Default value is 'false'
    exposed: true

    # Mandatory
    # This is used to be able to see the cloud cost for a team. It is important
    # to set this consistently for all team apps
    billingProject: "ssb-klass"

    # Mandatory
    # The Docker image and tag to deploy. The repo is usually
    # 'eu.gcr.io/prod-bip/<name>' for normal SSB applications
    image:
      repository: eu.gcr.io/prod-bip/ssb/dapla/klass-subsets-api
      tag: 'development-imagescan-cf399f2c62288ead93ed1f904e67b5aaca8435ad'

    # Optional
    # The number of Kubernetes pods to deploy. This should be higher than 1 if
    # you do not want downtime when deploying new versions
    replicaCount: 1

    # Mandatory
    # Always override this so you can specify the main container port that your
    # application is running on. When running behind Istio, the port names must
    # always include the protocol as a prefix (e.g. 'http-podinfo' or
    # 'grpc-podinfo'). See https://istio.io/docs/ops/deployment/requirements/
    # for more information. The default service port is '80' for the main port
    # configuration. If you need to expose additional ports, use 'extraPorts'
    port:
      name: "http-klass-subsets-api"
      containerport: 5000

    # Optional
    # This array can be used to open up additional application container ports.
    # A typical scenario where this could be used is when you use gRPC for
    # backend communication, but still use HTTP REST for other communication.
    # this array is empty by default
    # extraPorts:
    #  - name: "grpc-podinfo"
    #    containerport: 1408

    # Optional
    # A list of environment variables to add to the application container. These
    # can be plaintext variables, or come from a Kubernetes Secret
    environmentVariables:
      #  - name: "ENVIRONMENT"
      #    value: "staging"
      #  - name: "DB_USERNAME"
      #    valueFrom:
      #      secretKeyRef:
      #        name: "db-credentials"
      #        key: "username"
      #  - name: "DB_PASSWORD"
      #    valueFrom:
      #      secretKeyRef:
      #        name: "db-credentials"
      #        key: "password"
      - name: "API_LDS"
        value: "https://lds-klass.staging-bip-app.ssb.no/ns/ClassificationSubset"
      - name: "API_KLASS"
        value: "https://data.ssb.no/api/klass/v1/classifications"

    # Optional
    # A list of configuration files that are mounted in the main application
    # container at 'mountPath'. These files would be mounted as
    # '/etc/application.properties' and '/config/config.yaml'. Whenever the
    # 'config' section changes the deployment replicas will be re-started
    # automatically to ensure the application reads the updated configs
    # configs:
    #  - name: application.properties
    #    config: |
    #      key1=value1
    #      key2=value2
    #      key3=value3
    #    mountPath: /etc
    #  - name: config.yaml
    #    config: |
    #      key1: value1
    #      key2: value2
    #      key3: value3
    #    mountPath: /config

    # Optional (but should be considered mandatory)
    # This will specify the resource limits and resource requests for
    # the main application container. Requests are what the container is
    # guaranteed to get. Limits, on the other hand, make sure a container never
    # goes above a certain value. Note that it is a very good practice to set
    # this up, and to tweak this as you see the actual resource usage of an
    # application. If you do not set this, you will get really low resource
    # defaults, that is not production-friendly. Please do not copy this
    # blindly. Read more about this at
    # https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    resources:
      enabled: true
      limits:
        memory: 512Mi
      requests:
        cpu: 100m
        memory: 256Mi

    # Optional
    # If your app has Kubernetes liveness and readiness probes, you should
    # enable these. You should know the difference between liveness and
    # readiness. It does not make sense to use the same endpoint for both. If
    # your app has a liveness probe, you have to override the
    # 'livenessProbe.httpGet.port' and 'livenessProbe.httpGet.path'. If your app
    # has a readiness probe, you have to override the
    # 'readinessProbe.httpGet.port' and 'readinessProbe.httpGet.path'. Read more
    # at https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
    probes:
      liveness:
        enabled: false
      #    livenessProbe:
      #      httpGet:
      #        port: 9898
      #        path: "/health/liveness"
      readiness:
        enabled: false
    #    readinessProbe:
    #      httpGet:
    #        port: 9898
    #        path: "/health/readiness"

    # Optional
    # If the app has a Prometheus metrics endpoint, this should be 'true'. If
    # the metrics endpoint is something other than '/metrics', you should also
    # override 'path' with the correct endpoint for metrics (e.g. '/prometheus')
    metrics:
      enabled: false
    #  path: "/metrics"

    # Optional
    # If you have requirements on managed infrastructure like Google Cloud SQL
    # or Google Cloud Storage, we are using Workload Identity to grant a
    # Kubernetes workload access to certain resources. This means that a
    # Kubernetes service account acts as a Google Cloud Platform service account
    # that has the necessary access. We need to tell Kubernetes what GCP service
    # account to use, which is why we need to add an annotation to the
    # 'ServiceAccount' object in these situations. This is set up by the
    # platform team, so the service account name will be provided by them. See
    # more information at https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity
    #serviceAccount:
    #  annotations:
    #    iam.gke.io/gcp-service-account: "<provided by platform team>"

    # Optional
    # Defines a list of external https resources you need to be able to reach
    # from your application. Wildcard is supported, but the Helm chart will
    # replace '*' with 'wildcard' to avoid errors. Normally you do not need to
    # override this
    egress:
      - "data.ssb.no"
      - "lds-klass.staging-bip-app.ssb.no"

    # Optional
    # If your application needs to use an external database you need to talk to
    # the platform team to ensure this exists. Then you will receive an instance
    # connect string, as well as an IP that you will use in this override. When
    # overridden, your application will get an extra proxy running alongside
    # your conatainer that is able to reach an external Google Cloud SQL
    # database
    cloudsql:
      enabled: false
    #  instance: "<provided by platform team>"
    #  ip: "<provided by platform team>"

    # Optional
    # When setting up a frontend application, you sometimes need to send
    # authenticated requests to backends. When adding a list of backends that
    # you should be able to reach, an API Gateway proxy will be set up acting as
    # a backend for your frontend (frontend-backend) that can route requests to
    # certain backends (backend-backend) including the bearer token. This is
    # done to avoid using implicit flow in frontends, and having to set up CORS.
    # Remember that any backends that a frontend should be able to reach must be
    # added as audience in the Keycloak client that is currently set up by the
    # platform team. The backends are reachable by internal Kubernetes DNS on
    # '<service>.<namespace>', which is why you need to specify this per backend
    # you need to reach
    # backends:
    #  - name: "lds-klass"
    #    namespace: "klass"